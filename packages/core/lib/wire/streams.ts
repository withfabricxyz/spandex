import { type ProviderKey, type Quote, QuoteError } from "../types.js";
import { deserializeWithBigInt, serializeWithBigInt } from "./serde.js";

// Magic header bits to identify the stream format
const STREAM_MAGIC = 0xdec5feed;
// Currently no flags are defined (reserved for future use)
const STREAM_FLAGS = 0;

/**
 * Produce a ReadableStream that streams serialized Quote objects as they are resolved.
 * This is used when quotes are fetched on the server and need to be streamed to the client as they arrive.
 *
 * @param promises array of promises to resolve and write to stream as resolved
 * @returns ReadableStream that streams serialized Quote objects as they are resolved
 */
export function newQuoteStream(promises: Array<Promise<Quote>>): ReadableStream<Uint8Array> {
  if (promises.length > 0xff) {
    throw new Error("Cannot create quote stream: number of quotes exceeds 255.");
  }

  return new ReadableStream<Uint8Array>({
    start(controller) {
      let count = promises.length;
      controller.enqueue(encodeHeaderFrame(count));

      function tryClose() {
        try {
          controller.close();
        } catch {}
      }

      if (count === 0) {
        tryClose();
        return;
      }

      const finish = () => {
        count -= 1;
        if (count === 0) {
          tryClose();
        }
      };

      // Enqueue each quote as it resolves, and call finish when done
      for (const promise of promises) {
        promise
          .then((quote) => quote)
          .catch((error) => toFailedQuote(error))
          .then((quote) => {
            controller.enqueue(encodeQuoteFrame(quote));
          })
          .finally(finish);
      }
    },
  });
}

/**
 * Decode a ReadableStream of serialized Quote objects into an array of Promises that resolve to each Quote as it is streamed.
 *
 * @param stream A ReadableStream that was generated by readableQuoteStream
 *
 * @returns An array of Promises that resolve to each Quote as it is streamed
 */
export async function decodeQuoteStream(
  stream: ReadableStream<Uint8Array>,
): Promise<Array<Promise<Quote>>> {
  const reader = stream.getReader();
  let buffer: Uint8Array = new Uint8Array(0);

  while (buffer.length < 6) {
    const { value, done } = await reader.read();
    if (done) {
      reader.releaseLock();
      throw new Error("Quote stream ended before header was received.");
    }
    buffer = appendBuffer(buffer, value);
  }

  const { count } = decodeHeaderFrame(buffer.subarray(0, 6));
  const deferred = Array.from({ length: count }, () => createDeferred<Quote>());
  buffer = buffer.slice(6);

  void (async () => {
    let index = 0;

    try {
      while (index < count) {
        while (true) {
          if (buffer.length < 4) {
            break;
          }
          const payloadLength = new DataView(buffer.buffer, buffer.byteOffset, 4).getUint32(
            0,
            false,
          );
          const frameLength = 4 + payloadLength;
          if (buffer.length < frameLength) {
            break;
          }
          const frame = buffer.subarray(0, frameLength);
          const quote = decodeQuoteFrame(frame);
          if (!quote) {
            break;
          }
          deferred[index]?.resolve(quote);
          index += 1;
          buffer = buffer.slice(frameLength);
        }

        if (index >= count) {
          break;
        }

        const { value, done } = await reader.read();
        if (done) {
          break;
        }
        buffer = appendBuffer(buffer, value);
      }

      if (index < count) {
        const error = new Error("Quote stream ended before all quotes were received.");
        for (let i = index; i < count; i += 1) {
          deferred[i]?.reject(error);
        }
      }
    } catch (error) {
      for (let i = index; i < count; i += 1) {
        deferred[i]?.reject(error);
      }
    } finally {
      reader.releaseLock();
    }
  })();

  return deferred.map(({ promise }) => promise);
}

/// Helper Functions ///

function toFailedQuote(error: unknown): Quote {
  if (error && typeof error === "object") {
    if ("success" in error) {
      return error as Quote;
    }
    if ("provider" in error && typeof (error as { provider?: unknown }).provider === "string") {
      const provider = (error as { provider: ProviderKey }).provider;
      return {
        success: false,
        provider,
        error:
          error instanceof QuoteError ? error : new QuoteError("Quote promise rejected", error),
      };
    }
  }

  return {
    success: false,
    provider: "fabric",
    error: error instanceof QuoteError ? error : new QuoteError("Quote promise rejected", error),
  };
}

function createDeferred<T>() {
  let resolve!: (value: T) => void;
  let reject!: (error: unknown) => void;
  const promise = new Promise<T>((innerResolve, innerReject) => {
    resolve = innerResolve;
    reject = innerReject;
  });
  return { promise, resolve, reject };
}

// Note: The added flags byte here is reserved for future use (in case we want to add features to the stream format without breaking compatibility)
function encodeHeaderFrame(count: number): Uint8Array {
  const header = new Uint8Array(6);
  const headerView = new DataView(header.buffer);
  headerView.setUint32(0, STREAM_MAGIC, false);
  headerView.setUint8(4, STREAM_FLAGS);
  headerView.setUint8(5, count);
  return header;
}

function decodeHeaderFrame(frame: Uint8Array): { count: number } {
  const view = new DataView(frame.buffer, frame.byteOffset, frame.byteLength);
  const magic = view.getUint32(0, false);
  const flags = view.getUint8(4);
  const count = view.getUint8(5);
  if (magic !== STREAM_MAGIC || flags !== STREAM_FLAGS) {
    throw new Error("Unsupported quote stream header.");
  }
  return { count };
}

function appendBuffer(buffer: Uint8Array, chunk?: Uint8Array): Uint8Array {
  if (!chunk || chunk.length === 0) {
    return buffer;
  }
  if (buffer.length === 0) {
    return chunk;
  }
  const next = new Uint8Array(buffer.length + chunk.length);
  next.set(buffer);
  next.set(chunk, buffer.length);
  return next;
}

function encodeQuoteFrame(quote: Quote): Uint8Array {
  const encoder = new TextEncoder();
  const payload = encoder.encode(serializeWithBigInt(quote));
  const frame = new Uint8Array(4 + payload.length);
  const view = new DataView(frame.buffer);
  view.setUint32(0, payload.length, false);
  frame.set(payload, 4);
  return frame;
}

function decodeQuoteFrame(frame: Uint8Array): Quote | undefined {
  const view = new DataView(frame.buffer, frame.byteOffset, frame.byteLength);
  const payloadLength = view.getUint32(0, false);
  if (frame.byteLength - 4 < payloadLength) {
    return undefined;
  }
  const payload = frame.subarray(4, 4 + payloadLength);
  const decoder = new TextDecoder();
  return deserializeWithBigInt<Quote>(decoder.decode(payload));
}
